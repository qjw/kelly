// Copyright 2017 King Qiu.  All rights reserved.
// Use of this source code is governed by a MIT style
// license that can be found in the LICENSE file.
// https://github.com/qjw/kelly

package sessions

import (
	"fmt"
	"net/http"
	"github.com/qjw/kelly"
)

const (
	DefaultRegistryKey = "registrys"
	FlashKey           = "_flash"
)

// NewSession is called by session stores to create a new session instance.
func NewSession(store Store, name string) *SessionImp {
	return &SessionImp{
		ID:      "",
		name:    name,
		store:   store,
		written: false,
		Values:  make(map[interface{}]interface{}),
		Options: nil,
		IsNew:   true,
	}
}

type SessionImp struct {
	// The ID of the session, generated by stores. It should not be used for
	// user data.
	ID string

	name string

	c *kelly.Context

	store   Store
	written bool

	// Values contains the user-data for the session.
	Values  map[interface{}]interface{}
	Options *Options
	IsNew   bool
}

func (s *SessionImp) Get(key interface{}) interface{} {
	return s.Values[key]
}

func (s *SessionImp) Set(key interface{}, val interface{}) {
	s.Values[key] = val
	s.written = true
}

func (s *SessionImp) Delete(key interface{}) {
	delete(s.Values, key)
	s.written = true
}

func (s *SessionImp) Clear() {
	for key := range s.Values {
		s.Delete(key)
	}
}

func (s *SessionImp) AddFlash(value interface{}, vars ...string) {
	key := FlashKey
	if len(vars) > 0 {
		key = vars[0]
	}
	var flashes []interface{}
	if v, ok := s.Values[key]; ok {
		flashes = v.([]interface{})
	}
	s.Values[key] = append(flashes, value)
	s.written = true
}

func (s *SessionImp) Flashes(vars ...string) []interface{} {
	s.written = true
	var flashes []interface{}
	key := FlashKey
	if len(vars) > 0 {
		key = vars[0]
	}
	if v, ok := s.Values[key]; ok {
		// Drop the flashes and return it.
		delete(s.Values, key)
		flashes = v.([]interface{})
	}
	return flashes
}

func (s *SessionImp) Save() error {
	if s.Written() {
		e := s.store.Save(s.c, s)
		if e == nil {
			s.written = false
		}
		return e
	}
	return nil
}

func (s *SessionImp) Written() bool {
	return s.written
}

// sessionInfo stores a session tracked by the registry.
type sessionInfo struct {
	s *SessionImp
	e error
}

func GetRegistry(c *kelly.Context) *Registry {
	registry := c.Get(DefaultRegistryKey)
	if registry != nil {
		return registry.(*Registry)
	}
	newRegistry := &Registry{
		c:        c,
		sessions: make(map[string]sessionInfo),
	}
	c.Set(DefaultRegistryKey, newRegistry)
	return newRegistry
}

// Registry stores sessions used during a request.
type Registry struct {
	c        *kelly.Context
	sessions map[string]sessionInfo
}

// Get registers and returns a session for the given name and session store.
//
// It returns a new session if there are no sessions registered for the name.
func (s *Registry) Get(store Store, name string) (session *SessionImp, err error) {
	if !isCookieNameValid(name) {
		return nil, fmt.Errorf("sessions: invalid character in cookie name: %s", name)
	}
	if info, ok := s.sessions[name]; ok {
		session, err = info.s, info.e
	} else {
		var nsession Session
		nsession, err = store.New(s.c, name)
		session, ok = nsession.(*SessionImp)
		session.name = name
		session.c = s.c
		s.sessions[name] = sessionInfo{s: session, e: err}
	}
	session.store = store
	return
}

// Save saves all sessions registered for the current request.
func (s *Registry) Save(w http.ResponseWriter) error {
	var errMulti MultiError
	for name, info := range s.sessions {
		session := info.s
		if session.store == nil {
			errMulti = append(errMulti, fmt.Errorf(
				"sessions: missing store for session %q", name))
		} else if err := session.store.Save(s.c, session); err != nil {
			errMulti = append(errMulti, fmt.Errorf(
				"sessions: error saving session %q -- %v", name, err))
		}
	}
	if errMulti != nil {
		return errMulti
	}
	return nil
}

// Error ----------------------------------------------------------------------

// MultiError stores multiple errors.
//
// Borrowed from the App Engine SDK.
type MultiError []error

func (m MultiError) Error() string {
	s, n := "", 0
	for _, e := range m {
		if e != nil {
			if n == 0 {
				s = e.Error()
			}
			n++
		}
	}
	switch n {
	case 0:
		return "(0 errors)"
	case 1:
		return s
	case 2:
		return s + " (and 1 other error)"
	}
	return fmt.Sprintf("%s (and %d other errors)", s, n-1)
}
